<?php

use LBHurtado\OMRAppreciation\Services\AppreciationService;
use LBHurtado\OMRAppreciation\Services\FiducialDetector;
use LBHurtado\OMRAppreciation\Services\ImageAligner;
use LBHurtado\OMRAppreciation\Services\MarkDetector;

test('can normalize array fiducials to associative format', function () {
    $service = new AppreciationService(
        new FiducialDetector(),
        new ImageAligner(),
        new MarkDetector()
    );
    
    // Array format (as generated by omr:generate)
    $arrayFormat = [
        ['id' => 'top_left', 'x' => 100, 'y' => 100],
        ['id' => 'top_right', 'x' => 500, 'y' => 100],
        ['id' => 'bottom_left', 'x' => 100, 'y' => 700],
        ['id' => 'bottom_right', 'x' => 500, 'y' => 700],
    ];
    
    // Use reflection to access protected method
    $reflection = new ReflectionClass($service);
    $method = $reflection->getMethod('normalizeFiducials');
    $method->setAccessible(true);
    
    $result = $method->invoke($service, $arrayFormat);
    
    // Should be converted to associative array
    expect($result)->toBeArray()
        ->and($result)->toHaveKeys(['top_left', 'top_right', 'bottom_left', 'bottom_right'])
        ->and($result['top_left'])->toHaveKeys(['id', 'x', 'y'])
        ->and($result['top_left']['x'])->toBe(100)
        ->and($result['top_right']['x'])->toBe(500);
});

test('normalizeFiducials returns associative array unchanged', function () {
    $service = new AppreciationService(
        new FiducialDetector(),
        new ImageAligner(),
        new MarkDetector()
    );
    
    // Already in associative format
    $associativeFormat = [
        'top_left' => ['x' => 100, 'y' => 100],
        'top_right' => ['x' => 500, 'y' => 100],
        'bottom_left' => ['x' => 100, 'y' => 700],
        'bottom_right' => ['x' => 500, 'y' => 700],
    ];
    
    $reflection = new ReflectionClass($service);
    $method = $reflection->getMethod('normalizeFiducials');
    $method->setAccessible(true);
    
    $result = $method->invoke($service, $associativeFormat);
    
    // Should be returned unchanged
    expect($result)->toBe($associativeFormat);
});

test('can appreciate document with array format fiducials', function () {
    // Create test image with fiducials
    $image = imagecreatetruecolor(600, 800);
    $white = imagecolorallocate($image, 255, 255, 255);
    $black = imagecolorallocate($image, 0, 0, 0);
    imagefilledrectangle($image, 0, 0, 600, 800, $white);
    
    // Fiducials
    imagefilledrectangle($image, 20, 20, 60, 60, $black);
    imagefilledrectangle($image, 540, 20, 580, 60, $black);
    imagefilledrectangle($image, 20, 740, 60, 780, $black);
    imagefilledrectangle($image, 540, 740, 580, 780, $black);
    
    // Some filled marks
    imagefilledrectangle($image, 100, 150, 130, 180, $black);
    
    $imagePath = __DIR__ . '/../fixtures/test-array-fiducials.png';
    imagepng($image, $imagePath);
    imagedestroy($image);
    
    // Template with array format fiducials (like omr:generate output)
    $templateData = [
        'document_id' => 'ARRAY-TEST-001',
        'template_id' => 'test',
        'fiducials' => [
            ['id' => 'top_left', 'x' => 40, 'y' => 40, 'width' => 40, 'height' => 40],
            ['id' => 'top_right', 'x' => 560, 'y' => 40, 'width' => 40, 'height' => 40],
            ['id' => 'bottom_left', 'x' => 40, 'y' => 760, 'width' => 40, 'height' => 40],
            ['id' => 'bottom_right', 'x' => 560, 'y' => 760, 'width' => 40, 'height' => 40],
        ],
        'zones' => [
            ['id' => 'Q1', 'x' => 100, 'y' => 150, 'width' => 30, 'height' => 30],
            ['id' => 'Q2', 'x' => 100, 'y' => 200, 'width' => 30, 'height' => 30],
        ],
    ];
    
    $service = app(AppreciationService::class);
    $result = $service->appreciate($imagePath, $templateData);
    
    // Should work without errors
    expect($result)->toHaveKeys(['document_id', 'template_id', 'marks', 'summary'])
        ->and($result['document_id'])->toBe('ARRAY-TEST-001')
        ->and($result['marks'])->toHaveCount(2);
    
    unlink($imagePath);
});
